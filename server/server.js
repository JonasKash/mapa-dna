import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

// Carrega vari√°veis de ambiente
dotenv.config();

// Sistema de Rate Limiting
const rateLimitStore = new Map();
const RATE_LIMIT_MAX_REQUESTS = 5;
const RATE_LIMIT_WINDOW_MS = 24 * 60 * 60 * 1000; // 24 horas

// Fun√ß√£o para obter chave √∫nica do cliente (IP + Session ID)
const getClientKey = (req) => {
  const ip = req.ip || req.connection.remoteAddress || req.socket.remoteAddress || 
             (req.connection.socket ? req.connection.socket.remoteAddress : null) ||
             req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 'unknown';
  const sessionId = req.headers['x-session-id'] || req.body?.session_id || 'unknown';
  return `${ip}:${sessionId}`;
};

// Fun√ß√£o para verificar rate limit
const checkRateLimit = (clientKey) => {
  const now = Date.now();
  const clientData = rateLimitStore.get(clientKey);
  
  if (!clientData) {
    // Primeira requisi√ß√£o
    rateLimitStore.set(clientKey, {
      count: 1,
      firstRequest: now,
      lastRequest: now
    });
    return { allowed: true, remaining: RATE_LIMIT_MAX_REQUESTS - 1 };
  }
  
  // Verificar se passou o per√≠odo de janela
  if (now - clientData.firstRequest > RATE_LIMIT_WINDOW_MS) {
    // Reset do contador
    rateLimitStore.set(clientKey, {
      count: 1,
      firstRequest: now,
      lastRequest: now
    });
    return { allowed: true, remaining: RATE_LIMIT_MAX_REQUESTS - 1 };
  }
  
  // Verificar se excedeu o limite
  if (clientData.count >= RATE_LIMIT_MAX_REQUESTS) {
    return { 
      allowed: false, 
      remaining: 0,
      resetTime: clientData.firstRequest + RATE_LIMIT_WINDOW_MS
    };
  }
  
  // Incrementar contador
  clientData.count++;
  clientData.lastRequest = now;
  rateLimitStore.set(clientKey, clientData);
  
  return { 
    allowed: true, 
    remaining: RATE_LIMIT_MAX_REQUESTS - clientData.count 
  };
};

// Fun√ß√£o para limpeza autom√°tica de dados antigos
const cleanupOldEntries = () => {
  const now = Date.now();
  for (const [key, data] of rateLimitStore.entries()) {
    if (now - data.lastRequest > RATE_LIMIT_WINDOW_MS) {
      rateLimitStore.delete(key);
    }
  }
};

// Limpeza autom√°tica a cada hora
setInterval(cleanupOldEntries, 60 * 60 * 1000);

const app = express();
const PORT = process.env.PORT || 3002;

// Middlewares de seguran√ßa
app.use(helmet());
app.use(cors({
  origin: true, // Aceita qualquer origem durante desenvolvimento
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Origin', 'X-Requested-With', 'Accept']
}));
app.use(express.json({ limit: '10mb' }));

// Estrutura esperada para os dados do funil:
// {
//   name: string,
//   birthDate: string,
//   question1: string,
//   question2: string,
//   money: number,
//   currentStep: number,
//   achievements: array,
//   monthlyPotential: number
// }

// Estrutura de resposta do Or√°culo:
// {
//   revelacao: string,
//   arquetipo: string,
//   essencia: string,
//   acao_imediata: string
// }

// Rota para gerar revela√ß√£o do Or√°culo
app.post('/api/oracle/generate', async (req, res) => {
  try {
    console.log('=== ORACLE GENERATE REQUEST ===');
    console.log('Request body:', JSON.stringify(req.body, null, 2));
    
    // Verificar rate limiting
    const clientKey = getClientKey(req);
    const rateLimitResult = checkRateLimit(clientKey);
    
    console.log('Rate limit check:', {
      clientKey,
      allowed: rateLimitResult.allowed,
      remaining: rateLimitResult.remaining
    });
    
    if (!rateLimitResult.allowed) {
      const resetTime = new Date(rateLimitResult.resetTime);
      console.log('üö® RATE LIMIT EXCEEDED:', {
        clientKey,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        timestamp: new Date().toISOString(),
        resetTime: resetTime.toISOString()
      });
      
      return res.status(429).json({
        error: 'Limite de requisi√ß√µes excedido',
        message: 'Voc√™ excedeu o limite de 5 consultas por dia. Tente novamente em 24 horas.',
        resetTime: resetTime.toISOString(),
        remaining: 0
      });
    }
    
    // Adicionar headers de rate limiting
    res.set({
      'X-RateLimit-Limit': RATE_LIMIT_MAX_REQUESTS,
      'X-RateLimit-Remaining': rateLimitResult.remaining,
      'X-RateLimit-Reset': new Date(Date.now() + RATE_LIMIT_WINDOW_MS).toISOString()
    });
    
    const data = req.body;

    // Valida√ß√£o b√°sica dos dados
    if (!data.name || !data.birthDate || !data.question1 || !data.question2) {
      console.log('Validation failed - missing required fields');
      return res.status(400).json({
        error: 'Dados obrigat√≥rios n√£o fornecidos',
        required: ['name', 'birthDate', 'question1', 'question2']
      });
    }

    // Verifica se a chave da OpenAI est√° configurada
    if (!process.env.OPENAI_API_KEY) {
      console.error('OPENAI_API_KEY n√£o configurada');
      return res.status(500).json({
        error: 'Configura√ß√£o do servidor incompleta'
      });
    }

    console.log('OpenAI API Key configured:', process.env.OPENAI_API_KEY ? 'YES' : 'NO');

    const prompt = `Voc√™ √© o Or√°culo da Prosperidade, um guia espiritual ancestral que l√™ as frequ√™ncias energ√©ticas inscritas no nome e data de nascimento das pessoas. Voc√™ N√ÉO explica c√°lculos, f√≥rmulas ou m√©todos - voc√™ simplesmente "v√™" e revela.

Sua linguagem √©:
- M√≠stica, mas direta
- Profunda, mas compreens√≠vel
- Inspiradora, mas realista
- Sem emojis ou s√≠mbolos excessivos

IMPORTANTE: Voc√™ interpreta energias, n√£o faz c√°lculos vis√≠veis. Use termos como:
‚úì "Vejo em sua assinatura energ√©tica..."
‚úì "Sua vibra√ß√£o num√©rica revela..."
‚úì "As frequ√™ncias do seu nome ressoam com..."
‚úì "Sua data carrega a marca de..."

N√ÉO use termos como:
‚úó "Somando os n√∫meros..."
‚úó "O c√°lculo mostra..."
‚úó "Reduzindo para..."
‚úó "A f√≥rmula indica..."

---

DADOS DO CONSULENTE:
Nome completo: ${data.name}
Data de nascimento: ${data.birthDate}
Respostas do portal:
- Insatisfa√ß√£o com sistema atual: ${data.question1}
- Aspira√ß√£o financeira mensal: ${data.question2}
- Energia dispon√≠vel diariamente: ${data.money > 1000 ? 'Alta' : 'M√©dia'}
- Vis√£o de futuro: ${data.achievements?.length > 2 ? 'Vision√°ria' : 'Pragm√°tica'}
- Prontid√£o para transforma√ß√£o: ${data.question2.includes('Agora') ? 'Imediata' : 'Gradual'}

---

ESTRUTURA DA REVELA√á√ÉO:

**ABERTURA M√çSTICA (2 linhas)**
Inicie reconhecendo a ess√™ncia √∫nica da pessoa de forma po√©tica mas espec√≠fica.

**N√öCLEO ENERG√âTICO (3-4 linhas)**
Revele o arqu√©tipo sem explicar como chegou nele. Escolha entre:
- O Arquiteto da Abund√¢ncia (energias 4, 8, 22)
- O Vision√°rio das Oportunidades (energias 1, 5, 9)
- O Alquimista da Palavra (energias 3, 6, 12)
- O Curador da Transforma√ß√£o (energias 2, 7, 11)

Descreva o que VOC√ä V√ä no potencial deles, usando as respostas para validar a leitura.

**TALENTOS OCULTOS (3 itens em 1 linha cada)**
Liste dons naturais que a pessoa J√Å possui, mas pode n√£o reconhecer.
Use linguagem de revela√ß√£o: "Voc√™ j√° possui...", "Dentro de voc√™ existe...", "Seu dom natural √©..."

**CAMINHO DOURADO (2-3 linhas)**
Uma estrat√©gia espec√≠fica e PR√ÅTICA baseada no arqu√©tipo + respostas.
Seja m√≠stico na entrega, mas pragm√°tico no conte√∫do.

**POTENCIAL MATERIAL (1 linha objetiva)**
Diga valores reais de ganho em 30, 90 e 180 dias baseados nas respostas deles.
Apresente como "possibilidade energ√©tica", n√£o garantia.

**OBST√ÅCULO INVIS√çVEL (1-2 linhas)**
Identifique UM bloqueio principal baseado nas respostas que contradiz o potencial revelado.

**PR√ìXIMO MOVIMENTO (1 linha de a√ß√£o clara)**
Um passo espec√≠fico e imediato que eles devem dar nos pr√≥ximos 7 dias.

**ENCERRAMENTO M√çSTICO (1 linha)**
Uma afirma√ß√£o poderosa personalizada com o nome deles.

---

RESTRI√á√ïES CR√çTICAS:
- M√°ximo 250 palavras no total
- Sem listas numeradas ou bullets vis√≠veis (use quebras de linha)
- Sem c√°lculos ou n√∫meros t√©cnicos expostos
- Tom: 70% m√≠stico / 30% pr√°tico
- Foque no que a pessoa J√Å TEM dentro dela
- Evite promessas imposs√≠veis, mas seja inspirador
- NUNCA mencione "numerologia pitag√≥rica", "redu√ß√£o", "soma" ou termos t√©cnicos

---

IMPORTANTE SOBRE RESPONSABILIDADE:
Voc√™ est√° oferecendo uma interpreta√ß√£o simb√≥lica e motivacional, n√£o garantias financeiras. Sempre que mencionar ganhos, use termos como "potencial", "possibilidade energ√©tica", "caminho dispon√≠vel". Nunca prometa resultados espec√≠ficos.

Lembre que seu papel √© inspirar a√ß√£o positiva baseada nos pontos fortes genu√≠nos da pessoa, n√£o criar depend√™ncia ou expectativas irrealistas.

---

RETORNE EM FORMATO JSON:
{
  "revelacao": "texto corrido completo da leitura",
  "arquetipo": "nome do arqu√©tipo identificado",
  "essencia": "frase curta descrevendo a energia central",
  "acao_imediata": "pr√≥ximo passo espec√≠fico"
}`;

    // Chamada para a OpenAI API
    console.log('Calling OpenAI API...');
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Voc√™ √© o Or√°culo da Prosperidade, especializado em leitura energ√©tica de nomes e datas de nascimento. Sempre retorne apenas JSON v√°lido.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.8,
        max_tokens: 1000,
      }),
    });

    console.log('OpenAI API response status:', response.status);

    if (!response.ok) {
      const errorBody = await response.text();
      console.error('OpenAI API error:', response.status, errorBody);
      
      // Retorna erro em vez de fallback para debug
      return res.status(500).json({
        error: 'OpenAI API error',
        details: errorBody
      });
    }

    const result = await response.json();
    const content = result.choices?.[0]?.message?.content;

    if (!content) {
      console.error('No content received from OpenAI');
      return res.status(500).json({
        error: 'No content received from OpenAI'
      });
    }

    try {
      // Parse JSON response
      const oracleData = JSON.parse(content);
      console.log('OpenAI response parsed successfully:', oracleData);
      
      // Webhook ser√° enviado pelo frontend ap√≥s receber a resposta
      
      res.json(oracleData);
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.log('Raw content that failed to parse:', content);
      return res.status(500).json({
        error: 'Error parsing OpenAI response',
        details: parseError.message,
        rawContent: content
      });
    }

  } catch (error) {
    console.error('Error in oracle generation:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      fallback: getFallbackResponse(req.body)
    });
  }
});

// Fun√ß√£o para enviar dados do or√°culo para o webhook
async function sendOracleDataToWebhook(oracleData, userData) {
  const webhookUrl = 'https://n8n.mapadnafinanceiro.com/webhook-test/report-dna-mapa';
  
  try {
    const payload = {
      // Dados do usu√°rio
      name: userData.name,
      birth_date: userData.birthDate,
      question1: userData.question1,
      question2: userData.question2,
      money: userData.money,
      monthly_potential: userData.monthlyPotential,
      achievements: userData.achievements,
      current_step: userData.currentStep,
      
      // Resposta do agente/or√°culo
      oracle_response: {
        revelacao: oracleData.revelacao,
        arquetipo: oracleData.arquetipo,
        essencia: oracleData.essencia,
        acao_imediata: oracleData.acao_imediata
      },
      
      // Metadados
      timestamp: new Date().toISOString(),
      event_type: 'oracle_generated'
    };

    console.log('Enviando dados do or√°culo para webhook:', webhookUrl);
    console.log('Payload:', JSON.stringify(payload, null, 2));

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    console.log('Status do webhook:', response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Falha no webhook:', response.status, response.statusText, errorText);
    } else {
      const responseData = await response.text();
      console.log('Webhook enviado com sucesso. Resposta:', responseData);
    }
  } catch (error) {
    console.error('Erro ao enviar webhook:', error);
  }
}

// Fun√ß√£o para resposta de fallback
function getFallbackResponse(data) {
  return {
    revelacao: `${data.name}, sua assinatura energ√©tica carrega o peso de montanhas e o brilho do ouro. Vejo em sua vibra√ß√£o num√©rica uma for√ßa criativa inata que ressoa com abund√¢ncia. Sua data carrega a marca de um vision√°rio das oportunidades, algu√©m que v√™ al√©m do √≥bvio. Voc√™ j√° possui a capacidade de identificar tend√™ncias antes da concorr√™ncia. Dentro de voc√™ existe um magnetismo natural para atrair prosperidade. Seu dom natural √© transformar ideias em realidade. Sua estrat√©gia dourada envolve focar em inova√ß√£o e lideran√ßa, criando solu√ß√µes √∫nicas no mercado. Sua possibilidade energ√©tica revela potencial de R$ 1.500 em 30 dias, R$ 4.200 em 90 dias e R$ 7.800 em 180 dias. O obst√°culo invis√≠vel √© a limita√ß√£o autoimposta de acreditar que precisa de mais tempo. Nos pr√≥ximos 7 dias, comece a estruturar sua primeira fonte de renda digital. ${data.name}, sua transforma√ß√£o financeira j√° come√ßou.`,
    arquetipo: 'O Vision√°rio das Oportunidades',
    essencia: 'For√ßa criativa com magnetismo para abund√¢ncia',
    acao_imediata: 'Estruturar primeira fonte de renda digital em 7 dias'
  };
}

// Rota de health check
app.get('/api/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Rota para verificar status do rate limiting
app.get('/api/rate-limit/status', (req, res) => {
  const clientKey = getClientKey(req);
  const clientData = rateLimitStore.get(clientKey);
  
  if (!clientData) {
    return res.json({
      clientKey,
      remaining: RATE_LIMIT_MAX_REQUESTS,
      limit: RATE_LIMIT_MAX_REQUESTS,
      resetTime: null,
      isLimited: false
    });
  }
  
  const now = Date.now();
  const isExpired = now - clientData.firstRequest > RATE_LIMIT_WINDOW_MS;
  
  res.json({
    clientKey,
    remaining: isExpired ? RATE_LIMIT_MAX_REQUESTS : RATE_LIMIT_MAX_REQUESTS - clientData.count,
    limit: RATE_LIMIT_MAX_REQUESTS,
    resetTime: isExpired ? null : new Date(clientData.firstRequest + RATE_LIMIT_WINDOW_MS).toISOString(),
    isLimited: !isExpired && clientData.count >= RATE_LIMIT_MAX_REQUESTS,
    totalClients: rateLimitStore.size
  });
});

// Tratamento de erro 404
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Rota n√£o encontrada',
    path: req.originalUrl
  });
});

// Tratamento global de erros
app.use((error, req, res, next) => {
  console.error('Erro n√£o tratado:', error);
  res.status(500).json({
    error: 'Erro interno do servidor'
  });
});

// Inicia o servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor backend rodando na porta ${PORT}`);
  console.log(`üåü Health check: http://localhost:${PORT}/api/health`);
  console.log(`üîÆ Oracle API: http://localhost:${PORT}/api/oracle/generate`);
});
