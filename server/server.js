const express = require('express');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const axios = require('axios');
const dotenv = require('dotenv');

// Carregar vari√°veis de ambiente
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3002;

// Middleware
const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
};
app.use(cors(corsOptions));
app.use(express.json());

// Rate limiting geral (mais restritivo)
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 20, // Reduzido para evitar spam
  message: {
    error: 'Muitas tentativas. Tente novamente em 15 minutos.',
    retryAfter: 900
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => {
    // Pular rate limiting para health checks
    return req.path === '/health' || req.path === '/api/health';
  }
});

// Rate limiting espec√≠fico para gera√ß√£o de or√°culo (muito mais restritivo)
const oracleLimiter = rateLimit({
  windowMs: 3 * 60 * 60 * 1000, // 3 horas
  max: 3, // M√°ximo 3 tentativas por 3 horas por IP
  message: {
    error: 'Limite de consultas excedido. Voc√™ pode fazer apenas 3 consultas por 3 horas.',
    retryAfter: 10800, // 3 horas em segundos
    limit: 3,
    remaining: 0
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    // Usar IP + User-Agent para identificar melhor o usu√°rio
    const ip = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent') || '';
    return `${ip}-${userAgent.substring(0, 50)}`;
  },
  onLimitReached: (req, res, options) => {
    console.log(`üö´ Rate limit atingido para IP: ${req.ip}`);
    console.log(`üìä User-Agent: ${req.get('User-Agent')}`);
    console.log(`‚è∞ Pr√≥xima tentativa permitida em: ${new Date(Date.now() + options.windowMs).toISOString()}`);
  }
});

// Aplicar rate limiting geral sempre
app.use('/api/', generalLimiter);

// Aplicar rate limiting espec√≠fico para or√°culo sempre
app.use('/api/oracle/generate', oracleLimiter);

// Verificar configura√ß√£o
if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'sk-proj-test-key') {
  console.log('‚ö†Ô∏è Usando chave de teste - sistema funcionar√° com respostas artificiais');
  process.env.OPENAI_API_KEY = 'sk-proj-test-key';
}

console.log('‚úÖ Servidor configurado com sucesso');

// Fun√ß√£o para calcular numerologia pitag√≥rica
const calculateNumerology = (name, birthDate) => {
  const pythagoreanTable = {
    'A': 1, 'J': 1, 'S': 1,
    'B': 2, 'K': 2, 'T': 2,
    'C': 3, 'L': 3, 'U': 3,
    'D': 4, 'M': 4, 'V': 4,
    'E': 5, 'N': 5, 'W': 5,
    'F': 6, 'O': 6, 'X': 6,
    'G': 7, 'P': 7, 'Y': 7,
    'H': 8, 'Q': 8, 'Z': 8,
    'I': 9, 'R': 9
  };

  const fullName = name.toUpperCase().replace(/\s/g, '');
  const vowels = fullName.match(/[AEIOU]/g) || [];
  const consonants = fullName.match(/[BCDFGHJKLMNPQRSTVWXYZ]/g) || [];

  const soulEssence = vowels.reduce((sum, letter) => sum + (pythagoreanTable[letter] || 0), 0);
  const dreamsNumber = consonants.reduce((sum, letter) => sum + (pythagoreanTable[letter] || 0), 0);
  const expressionNumber = soulEssence + dreamsNumber;

  const reduceToSingleDigit = (num) => {
    if (num === 11 || num === 22 || num === 33) return num;
    while (num > 9) {
      num = num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }
    return num;
  };

  const birthDateStr = birthDate.replace(/-/g, '');
  const birthSum = birthDateStr.split('').reduce((sum, digit) => sum + parseInt(digit), 0);
  const birthNumber = reduceToSingleDigit(birthSum);

  const finalNumber = reduceToSingleDigit(expressionNumber + birthNumber);
  
  return { 
    soulEssence: reduceToSingleDigit(soulEssence),
    dreamsNumber: reduceToSingleDigit(dreamsNumber),
    expressionNumber: reduceToSingleDigit(expressionNumber),
    birthNumber: birthNumber,
    finalNumber: finalNumber
  };
};

// Fun√ß√£o para gerar resposta artificial baseada no hist√≥rico
const generateArtificialResponse = (data, numerology) => {
  const archetypes = {
    1: { name: "Arquiteto da Abund√¢ncia", essence: "Lideran√ßa e inova√ß√£o" },
    2: { name: "Vision√°rio das Oportunidades", essence: "Intui√ß√£o e colabora√ß√£o" },
    3: { name: "Alquimista da Palavra", essence: "Criatividade e express√£o" },
    4: { name: "Curador da Transforma√ß√£o", essence: "Estabilidade e cura" },
    5: { name: "Explorador da Liberdade", essence: "Aventura e mudan√ßa" },
    6: { name: "Guardi√£o da Harmonia", essence: "Responsabilidade e amor" },
    7: { name: "M√≠stico da Sabedoria", essence: "Espiritualidade e an√°lise" },
    8: { name: "Magnata do Poder", essence: "Autoridade e materializa√ß√£o" },
    9: { name: "Filantropo Universal", essence: "Servi√ßo e compaix√£o" },
    11: { name: "Curador da Transforma√ß√£o", essence: "Intui√ß√£o elevada e cura" },
    22: { name: "Construtor Mestre", essence: "Vis√£o global e manifesta√ß√£o" },
    33: { name: "Mestre da Compaix√£o", essence: "Servi√ßo universal e cura" }
  };

  const obstacles = [
    "procrastina√ß√£o excessiva que paralisa sua a√ß√£o",
    "excesso de oportunidades que dispersa seu foco",
    "excesso de conhecimentos que gera paralisia",
    "excesso de amizades ruins que drenam sua energia",
    "medo do sucesso que sabota suas conquistas",
    "perfeccionismo que impede a execu√ß√£o",
    "ansiedade que bloqueia sua intui√ß√£o",
    "depend√™ncia de aprova√ß√£o externa"
  ];

  const archetype = archetypes[numerology.finalNumber] || archetypes[1];
  const obstacle = obstacles[Math.floor(Math.random() * obstacles.length)];

  const responses = {
    "Dobrar Renda": "Estrat√©gia de m√∫ltiplas fontes de renda atrav√©s de investimentos e empreendedorismo digital",
    "Liberdade Financeira": "Caminho da independ√™ncia atrav√©s de ativos que geram renda passiva",
    "Investir Melhor": "Educa√ß√£o financeira e diversifica√ß√£o de portf√≥lio para maximizar retornos",
    "Sair das D√≠vidas": "Plano de reestrutura√ß√£o financeira e mudan√ßa de h√°bitos de consumo",
    "Aposentadoria": "Constru√ß√£o de patrim√¥nio de longo prazo com foco em seguran√ßa"
  };

  const strategy = responses[data.question1] || "Desenvolvimento de habilidades de alto valor e cria√ß√£o de m√∫ltiplas fontes de renda";

  // Gerar resposta baseada no prompt do Or√°culo da Prosperidade
  const name = data.name.split(' ')[0];
  const age = new Date().getFullYear() - new Date(data.birthDate).getFullYear();
  
  // Varia√ß√µes de linguagem m√≠stica
  const mysticalOpenings = [
    "Vejo em sua matriz energ√©tica",
    "Sua frequ√™ncia nominal carrega", 
    "A assinatura temporal do seu nascimento revela",
    "As for√ßas invis√≠veis que habitam seu nome",
    "Percebo em sua vibra√ß√£o fundamental",
    "Sua ess√™ncia numerol√≥gica pulsa com",
    "A geometria sagrada de sua exist√™ncia",
    "Os ecos do seu nome no cosmos"
  ];
  
  const energyWords = [
    "vibra√ß√£o", "frequ√™ncia", "assinatura", "matriz", "ess√™ncia", "pulsa√ß√£o", "reson√¢ncia", "harmonia"
  ];
  
  const opening = mysticalOpenings[Math.floor(Math.random() * mysticalOpenings.length)];
  const energyWord = energyWords[Math.floor(Math.random() * energyWords.length)];
  
  // Gerar revela√ß√£o personalizada
  const revelacao = generatePersonalizedRevelation(data, numerology, archetype, name, age, opening, energyWord);

  return {
    revelacao: revelacao,
    arquetipo: archetype.name,
    essencia: archetype.essence,
    obstaculo: obstacle,
    acao_imediata: "Nos pr√≥ximos 7 dias, escolha UMA a√ß√£o espec√≠fica e execute sem perfeicionismo",
    numero_final: numerology.finalNumber
  };
};

// Fun√ß√£o para gerar revela√ß√£o personalizada seguindo o prompt
const generatePersonalizedRevelation = (data, numerology, archetype, name, age, opening, energyWord) => {
  // 1. ABERTURA M√çSTICA
  const openingLines = [
    `${name}, ${opening} uma ${energyWord} que oscila entre a necessidade de controle e o desejo profundo de liberdade total.`,
    `${name}, ${opening} o peso de responsabilidades que voc√™ carrega desde jovem, e o brilho da liberdade que voc√™ ainda n√£o permitiu existir.`,
    `${name}, ${opening} uma contradi√ß√£o poderosa: a necessidade de seguran√ßa que voc√™ expressa e a sede de aventura que pulsa em sua ${energyWord}.`,
    `${name}, ${opening} uma ${energyWord} que ${getRandomVerb()} al√©m do que seus olhos f√≠sicos podem ver.`
  ];
  
  const openingText = openingLines[Math.floor(Math.random() * openingLines.length)];

  // 2. ARQU√âTIPO REVELADO
  const archetypeText = `${name}, sua resposta sobre ${data.question1} confirma o que j√° estava inscrito: voc√™ √© o ${archetype.name}.`;

  // 3. TALENTOS J√Å ATIVOS
  const talents = getTalentsForArchetype(archetype.name);
  const talentsText = talents.map(talent => `J√° existe em voc√™ ${talent}`).join('\n');

  // 4. CAMINHO DOURADO
  const goldenPath = getGoldenPathForArchetype(archetype.name, data);

  // 5. POSSIBILIDADES ENERG√âTICAS
  const possibilities = getPossibilitiesForAge(age, data);

  // 6. OBST√ÅCULO INVIS√çVEL
  const obstacle = getObstacleForArchetype(archetype.name, data);

  // 7. PR√ìXIMO MOVIMENTO
  const nextMove = getNextMoveForArchetype(archetype.name);

  // 8. ENCERRAMENTO
  const closing = getClosingForName(name, archetype.name);

  return `${openingText}\n\n${archetypeText}\n\n${talentsText}\n\n${goldenPath}\n\n${possibilities}\n\n${obstacle}\n\n${nextMove}\n\n${closing}`;
};

// Fun√ß√µes auxiliares
const getRandomVerb = () => {
  const verbs = ["vejo", "percebo", "sinto", "leio", "decodifico", "revelo", "desvelo", "capto"];
  return verbs[Math.floor(Math.random() * verbs.length)];
};

const getTalentsForArchetype = (archetypeName) => {
  const talentsMap = {
    "Arquiteto da Abund√¢ncia": [
      "a capacidade de inspirar outros sem esfor√ßo",
      "o dom de ver solu√ß√µes onde outros veem problemas", 
      "a habilidade natural de transformar ideias em a√ß√µes"
    ],
    "Vision√°rio das Oportunidades": [
      "a sensibilidade para captar oportunidades antes que se manifestem",
      "o dom de ler as necessidades n√£o expressas das pessoas",
      "a capacidade de sentir o momento certo para agir"
    ],
    "Alquimista da Palavra": [
      "o poder de transformar conceitos complexos em mensagens simples",
      "a habilidade de conectar pessoas atrav√©s de suas palavras",
      "o dom de criar pontes entre mundos diferentes"
    ],
    "Curador da Transforma√ß√£o": [
      "a capacidade de organizar o caos em sistemas funcionais",
      "o dom de construir bases s√≥lidas para qualquer projeto",
      "a habilidade de transformar sonhos em planos execut√°veis"
    ]
  };
  
  return talentsMap[archetypeName] || talentsMap["Arquiteto da Abund√¢ncia"];
};

const getGoldenPathForArchetype = (archetypeName, data) => {
  const paths = {
    "Arquiteto da Abund√¢ncia": "Sua energia se manifesta atrav√©s de sistemas que funcionam sem voc√™. Crie um produto digital que voc√™ vende enquanto dorme, ou construa uma equipe que executa sua vis√£o.",
    "Vision√°rio das Oportunidades": "Sua intui√ß√£o √© seu maior ativo financeiro. Desenvolva um servi√ßo de consultoria baseado em sua percep√ß√£o √∫nica, ou invista em ativos que voc√™ 'sente' que v√£o valorizar.",
    "Alquimista da Palavra": "Sua palavra tem poder de transforma√ß√£o. Crie conte√∫do que ensina o que voc√™ sabe, ou desenvolva um curso online que monetiza seu conhecimento.",
    "Curador da Transforma√ß√£o": "Sua energia se manifesta atrav√©s de sistemas organizados. Desenvolva um neg√≥cio escal√°vel com processos claros, ou invista em ativos que geram renda passiva atrav√©s de estruturas s√≥lidas."
  };
  
  return paths[archetypeName] || paths["Arquiteto da Abund√¢ncia"];
};

const getPossibilitiesForAge = (age, data) => {
  const baseAmount = data.question2 ? parseInt(data.question2.replace(/\D/g, '')) : 5000;
  const multiplier = age < 25 ? 0.3 : age < 35 ? 0.5 : 0.7;
  
  const amount30 = Math.round(baseAmount * multiplier * 0.1);
  const amount90 = Math.round(baseAmount * multiplier * 0.3);
  
  return `Energeticamente, vejo possibilidade de R$ ${amount30} em 30 dias, R$ ${amount90} em 90 dias, se voc√™ seguir o caminho que sua ess√™ncia indica.`;
};

const getObstacleForArchetype = (archetypeName, data) => {
  const obstacles = {
    "Arquiteto da Abund√¢ncia": "Mas vejo uma contradi√ß√£o: voc√™ quer liberdade total, mas ainda busca aprova√ß√£o externa para suas decis√µes.",
    "Vision√°rio das Oportunidades": "Por√©m, percebo um bloqueio: sua intui√ß√£o est√° sendo sufocada pela necessidade de 'provas' antes de agir.",
    "Alquimista da Palavra": "Contudo, sinto uma resist√™ncia: voc√™ tem medo de ser julgado por suas ideias, ent√£o prefere ficar na zona de conforto.",
    "Curador da Transforma√ß√£o": "Mas vejo uma contradi√ß√£o: voc√™ quer resultados r√°pidos, mas tem medo de assumir riscos calculados."
  };
  
  return obstacles[archetypeName] || obstacles["Arquiteto da Abund√¢ncia"];
};

const getNextMoveForArchetype = (archetypeName) => {
  const actions = {
    "Arquiteto da Abund√¢ncia": "Nos pr√≥ximos 7 dias, escolha 3 pessoas para compartilhar uma ideia que voc√™ tem guardada e pe√ßa feedback espec√≠fico.",
    "Vision√°rio das Oportunidades": "Nos pr√≥ximos 7 dias, fa√ßa 5 anota√ß√µes sobre 'sensa√ß√µes' que voc√™ teve sobre oportunidades e verifique se se concretizaram.",
    "Alquimista da Palavra": "Nos pr√≥ximos 7 dias, crie 3 conte√∫dos sobre algo que voc√™ domina e publique em uma rede social.",
    "Curador da Transforma√ß√£o": "Nos pr√≥ximos 7 dias, organize um projeto que est√° parado h√° mais de 30 dias e defina 3 passos concretos para execut√°-lo."
  };
  
  return actions[archetypeName] || actions["Arquiteto da Abund√¢ncia"];
};

const getClosingForName = (name, archetypeName) => {
  const closings = [
    `${name}, sua ess√™ncia de ${archetypeName} est√° pronta para se manifestar - permita-se receber.`,
    `${name}, o ${archetypeName} que habita em voc√™ est√° aguardando sua permiss√£o para transformar sua realidade.`,
    `${name}, sua vibra√ß√£o de ${archetypeName} est√° alinhada com a abund√¢ncia - confie no processo.`,
    `${name}, o ${archetypeName} que voc√™ carrega est√° destinado a prosperar - aceite sua miss√£o.`
  ];
  
  return closings[Math.floor(Math.random() * closings.length)];
};

// Fun√ß√£o para obter resposta de fallback
const getFallbackResponse = (data, numerology) => {
  return {
    revelacao: `${data.name}, sua ess√™ncia √∫nica vibra no n√∫mero ${numerology.finalNumber}, despertando o Arquiteto da Abund√¢ncia que habita em voc√™.`,
    arquetipo: "Arquiteto da Abund√¢ncia",
    essencia: "Lideran√ßa e inova√ß√£o",
    obstaculo: "Procrastina√ß√£o excessiva que paralisa sua a√ß√£o",
    acao_imediata: "Nos pr√≥ximos 7 dias, escolha UMA a√ß√£o espec√≠fica e execute sem perfeicionismo",
    numero_final: numerology.finalNumber
  };
};

// Health check - rota principal para Docker healthcheck
app.get('/health', (req, res) => {
  console.log('üîç Health check solicitado');
  res.status(200).send('OK');
});

// Health check - rota da API
app.get('/api/health', (req, res) => {
  console.log('üîç Health check solicitado');
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Reset rate limit (apenas para desenvolvimento)
app.post('/api/rate-limit/reset', (req, res) => {
  console.log('üîÑ Rate limit reset solicitado');
  res.json({ message: 'Rate limit resetado com sucesso' });
});

// Status do rate limiting
app.get('/api/rate-limit/status', (req, res) => {
  const clientIP = req.ip || req.connection.remoteAddress;
  res.json({
    ip: clientIP,
    userAgent: req.get('User-Agent'),
    timestamp: new Date().toISOString(),
    limits: {
      general: {
        windowMs: 15 * 60 * 1000,
        max: 20,
        description: '20 requisi√ß√µes por 15 minutos'
      },
      oracle: {
        windowMs: 3 * 60 * 60 * 1000,
        max: 3,
        description: '3 consultas de or√°culo por 3 horas'
      }
    }
  });
});

// Rota removida - webhook agora √© enviado automaticamente no /api/oracle/generate

// Endpoint principal para gerar or√°culo
app.post('/api/oracle/generate', async (req, res) => {
  const startTime = Date.now();
  const clientIP = req.ip || req.connection.remoteAddress;
  const userAgent = req.get('User-Agent') || 'Unknown';
  
  console.log('üîÆ Nova solicita√ß√£o de or√°culo recebida');
  console.log(`üåê IP: ${clientIP}`);
  console.log(`üì± User-Agent: ${userAgent}`);
  console.log('üìä Dados recebidos:', JSON.stringify(req.body, null, 2));

  try {
    const data = req.body;

    // Validar dados obrigat√≥rios
    if (!data.name || !data.birthDate || !data.question1 || !data.question2) {
      console.log('‚ùå Dados obrigat√≥rios ausentes');
      return res.status(400).json({
        error: 'Dados obrigat√≥rios ausentes: name, birthDate, question1, question2' 
      });
    }

    // Calcular numerologia
    console.log('üî¢ Calculando numerologia...');
    const numerology = calculateNumerology(data.name, data.birthDate);
    console.log('üìä Numerologia calculada:', numerology);

    // Se for chave de teste, usar sempre resposta artificial
    let usedFallback = false;
    
    if (process.env.OPENAI_API_KEY === 'sk-proj-test-key') {
      console.log('üé≠ Usando resposta artificial (chave de teste)');
      usedFallback = true;
    } else {
      // Configurar timeout de 10 segundos para OpenAI
      const openaiTimeout = 10000; // 10 segundos
      let openaiResponse = null;

      try {
        console.log('ü§ñ Enviando requisi√ß√£o para OpenAI...');
        
        const prompt = `Voc√™ √© o Or√°culo da Prosperidade. Leia as energias numerol√≥gicas do nome e data de nascimento. Seja direto e m√≠stico.

DADOS NUMEROL√ìGICOS:
Nome: ${data.name}
Nascimento: ${data.birthDate}
N√∫mero da Ess√™ncia da Alma: ${numerology.soulEssence}
N√∫mero dos Sonhos: ${numerology.dreamsNumber}
N√∫mero da Express√£o: ${numerology.expressionNumber}
N√∫mero do Nascimento: ${numerology.birthNumber}
N√öMERO FINAL: ${numerology.finalNumber}

DADOS PESSOAIS:
Insatisfa√ß√£o: ${data.question1}
Aspira√ß√£o: ${data.question2}
Energia: ${data.money > 1000 ? 'Alta' : 'M√©dia'}

ESTRUTURA (m√°ximo 150 palavras):

**ABERTURA (1 linha)**
Reconhe√ßa a ess√™ncia √∫nica baseada no N√öMERO FINAL ${numerology.finalNumber}.

**ARQU√âTIPO (2-3 linhas)**
Baseado no N√öMERO FINAL ${numerology.finalNumber}, escolha um:
- Arquiteto da Abund√¢ncia (1, 4, 7)
- Vision√°rio das Oportunidades (2, 5, 8)
- Alquimista da Palavra (3, 6, 9)
- Curador da Transforma√ß√£o (11, 22, 33)

Descreva o potencial baseado no n√∫mero e respostas.

**ESTRAT√âGIA (2 linhas)**
Caminho pr√°tico baseado no arqu√©tipo numerol√≥gico.

**POTENCIAL (1 linha)**
Valores em 30/90/180 dias como "possibilidade energ√©tica".

**OBST√ÅCULO (1 linha)**
UM bloqueio comum: procrastina√ß√£o excessiva, excesso de oportunidades, excesso de conhecimentos, excesso de amizades ruins, medo do sucesso, perfeicionismo, etc.

**A√á√ÉO (1 linha)**
Pr√≥ximo passo em 7 dias.

**FECHAMENTO (1 linha)**
Afirma√ß√£o com o nome e n√∫mero ${numerology.finalNumber}.

RETORNE JSON:
{
  "revelacao": "texto completo",
  "arquetipo": "nome do arqu√©tipo",
  "essencia": "energia central",
  "obstaculo": "bloqueio principal",
  "acao_imediata": "pr√≥ximo passo",
  "numero_final": ${numerology.finalNumber}
}`;

        const openaiRequest = axios.post('https://api.openai.com/v1/chat/completions', {
          model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
              content: 'Voc√™ √© um or√°culo m√≠stico especializado em numerologia pitag√≥rica e prosperidade financeira. Responda sempre em JSON v√°lido.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
          max_tokens: 800,
          temperature: 0.7
        }, {
          headers: {
            'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
            'Content-Type': 'application/json'
          },
          timeout: openaiTimeout
        });

        // Aguardar resposta com timeout
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('OpenAI timeout')), openaiTimeout)
        );

        openaiResponse = await Promise.race([openaiRequest, timeoutPromise]);
        
        console.log('‚úÖ Resposta da OpenAI recebida em', Date.now() - startTime, 'ms');
        console.log('üìù Tokens usados:', openaiResponse.data.usage?.total_tokens || 'N/A');

      } catch (openaiError) {
        console.log('‚ö†Ô∏è Erro na OpenAI ou timeout:', openaiError.message);
        console.log('üîÑ Usando resposta artificial...');
        usedFallback = true;
      }
    }

    let oracleData;

    if (usedFallback || !openaiResponse) {
      // Usar resposta artificial baseada no hist√≥rico
      console.log('‚è≥ Simulando processamento de 10 segundos...');
      await new Promise(resolve => setTimeout(resolve, 10000)); // 10 segundos de delay
      oracleData = generateArtificialResponse(data, numerology);
      console.log('üé≠ Resposta artificial gerada');
    } else {
      // Processar resposta da OpenAI
      try {
        const content = openaiResponse.data.choices[0].message.content;
        console.log('üìÑ Conte√∫do recebido da OpenAI:', content.substring(0, 200) + '...');
        
        // Tentar extrair JSON da resposta
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          oracleData = JSON.parse(jsonMatch[0]);
          console.log('‚úÖ JSON extra√≠do com sucesso');
        } else {
          throw new Error('JSON n√£o encontrado na resposta');
        }
      } catch (parseError) {
        console.log('‚ùå Erro ao processar resposta da OpenAI:', parseError.message);
        console.log('üîÑ Usando resposta artificial...');
        oracleData = generateArtificialResponse(data, numerology);
        usedFallback = true;
      }
    }

    // Garantir que todos os campos necess√°rios existam
    const finalResponse = {
      revelacao: oracleData.revelacao || getFallbackResponse(data, numerology).revelacao,
      arquetipo: oracleData.arquetipo || 'Arquiteto da Abund√¢ncia',
      essencia: oracleData.essencia || 'Lideran√ßa e inova√ß√£o',
      obstaculo: oracleData.obstaculo || 'Procrastina√ß√£o excessiva que paralisa sua a√ß√£o',
      acao_imediata: oracleData.acao_imediata || 'Nos pr√≥ximos 7 dias, escolha UMA a√ß√£o espec√≠fica e execute sem perfeicionismo',
      numero_final: oracleData.numero_final || numerology.finalNumber
    };

    console.log('üéØ Resposta final preparada');
    console.log('üìä Tempo total:', Date.now() - startTime, 'ms');
    console.log('üîÑ Fallback usado:', usedFallback);
    console.log(`‚úÖ Or√°culo entregue para IP: ${clientIP}`);

    // Enviar dados para webhook automaticamente (ass√≠ncrono)
    sendOracleDataToWebhook(finalResponse, data).catch(error => {
      console.error('‚ùå Erro ao enviar webhook:', error.message);
    });

    res.json(finalResponse);

  } catch (error) {
    console.error('üí• Erro no servidor:', error);
    res.status(500).json({
      error: 'Erro interno do servidor',
      details: error.message 
    });
  }
});

// Fun√ß√£o para enviar dados do or√°culo para webhook
async function sendOracleDataToWebhook(oracleData, userData) {
  const webhookUrl = process.env.WEBHOOK_URL || 'https://wbn.araxa.app/webhook/mapa-dna-financeiro';
  const timestamp = new Date().toISOString();
  
  try {
    const payload = {
      // Dados do usu√°rio
      name: userData.name,
      birth_date: userData.birthDate,
      whatsapp: userData.whatsapp || '',
      question1: userData.question1,
      question2: userData.question2,
      money: userData.money,
      monthly_potential: userData.monthlyPotential,
      achievements: userData.achievements,
      current_step: userData.currentStep,
      
      // Resposta do agente/or√°culo
      oracle_data: {
        revelacao: oracleData.revelacao,
        arquetipo: oracleData.arquetipo,
        essencia: oracleData.essencia,
        obstaculo: oracleData.obstaculo,
        acao_imediata: oracleData.acao_imediata,
        numero_final: oracleData.numero_final
      },
      
      // Metadados
      timestamp: timestamp,
      event_type: 'oracle_generated'
    };

    console.log('=== BACKEND WEBHOOK DEBUG START ===');
    console.log('Timestamp:', timestamp);
    console.log('Webhook URL:', webhookUrl);
    console.log('Payload size:', JSON.stringify(payload).length, 'bytes');
    console.log('User data keys:', Object.keys(userData));
    console.log('Oracle data keys:', Object.keys(oracleData));
    console.log('Full payload:', JSON.stringify(payload, null, 2));

    const response = await axios.post(webhookUrl, payload, {
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'MapaDNA-Backend/1.0',
      },
      timeout: 15000
    });

    console.log('=== BACKEND WEBHOOK SUCCESS ===');
    console.log('Response status:', response.status);
    console.log('Response statusText:', response.statusText);
    console.log('Response headers:', response.headers);
    console.log('Response data:', response.data);
    console.log('=== BACKEND WEBHOOK DEBUG END ===');
    return true;
  } catch (error) {
    console.error('=== BACKEND WEBHOOK ERROR ===');
    console.error('Error timestamp:', timestamp);
    console.error('Error type:', error.constructor.name);
    console.error('Error message:', error.message);
    
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response statusText:', error.response.statusText);
      console.error('Response headers:', error.response.headers);
      console.error('Response data:', error.response.data);
    } else if (error.request) {
      console.error('No response received');
      console.error('Request config:', error.config);
    } else {
      console.error('Error setting up request:', error.message);
    }
    
    console.error('=== BACKEND WEBHOOK DEBUG END ===');
    return false;
  }
}

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üåê Ambiente: ${process.env.NODE_ENV || 'development'}`);
  console.log(`‚è∞ Rate limiting geral: ATIVO (20 req/15min)`);
  console.log(`üîÆ Rate limiting or√°culo: ATIVO (3 req/3h)`);
  console.log(`üîó Webhook URL: ${process.env.WEBHOOK_URL || 'https://wbn.araxa.app/webhook/mapa-dna-financeiro'}`);
});
